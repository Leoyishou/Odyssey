---
draw:
tags: []
title: 后端方案
date created: 2024-01-03
date modified: 2024-11-12
---

## 可供参考的建表语句

```Java
CREATE TABLE Users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE Essays (
    essay_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES Users(user_id),
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE Sentences (
    sentence_id SERIAL PRIMARY KEY,
    essay_id INTEGER REFERENCES Essays(essay_id),
    content TEXT NOT NULL,
    position INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE Thoughts (
    thought_id SERIAL PRIMARY KEY,
    sentence TEXT NOT NULL,
    focus_left INTEGER NOT NULL,
    focus_right INTEGER NOT NULL,
    focus_word VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE Expressions (
    expression_id SERIAL PRIMARY KEY,
    written_expression VARCHAR(255) NOT NULL,
    oral_expression VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ActiveMappings (
    active_mapping_id SERIAL PRIMARY KEY,
    sentence_id INTEGER REFERENCES Sentences(sentence_id),
    thought_id INTEGER REFERENCES Thoughts(thought_id),
    expression_id INTEGER REFERENCES Expressions(expression_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE AIReviews (
    ai_review_id SERIAL PRIMARY KEY,
    active_mapping_id INTEGER REFERENCES ActiveMappings(active_mapping_id),
    is_correct BOOLEAN NOT NULL,
    ai_expression VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE MappingCards (
    mapping_card_id SERIAL PRIMARY KEY,
    active_mapping_id INTEGER REFERENCES ActiveMappings(active_mapping_id),
    user_expression VARCHAR(255),
    ai_expression VARCHAR(255),
    is_reviewed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ReviewSchedules (
    review_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES Users(user_id),
    mapping_card_id INTEGER REFERENCES MappingCards(mapping_card_id),
    review_interval INTEGER NOT NULL,
    next_review_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### DDD 中的路径

当一个保存 essay 的请求进入后端后，整个处理链路大致如下：

1. 接口层（Interface Layer）:

```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```

1. 应用层（Application Layer）:

```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```

1. 领域层（Domain Layer）:

```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```

1. 基础设施层（Infrastructure Layer）:

```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```

调用顺序：

1. HTTP 请求到达 `essay_controller.py` 中的 ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```0 函数。
2. ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```1 函数调用 ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```2 方法。
3. ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```3 方法执行以下步骤：
   a. 创建 ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```4 实体  
   b. 调用 ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```5 保存 Essay  
   c. 调用 ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```6 处理 Essay  
   d. 调用 ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```7 保存生成的 MappingCards  
   e. 返回处理结果

4. ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```8 方法执行以下步骤：
   a. 调用 ```python
# interfaces/api/essay_controller.py

@router.post("/essays")
async def process_essay(essay_content: str, use_case: ProcessEssayUseCase = Depends()):
    result = use_case.execute(essay_content)
    return result
```9 验证 Essay 内容  
   b. 调用 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```0 处理 Essay 内容  
   c. 根据处理结果创建 MappingCard 实体

5. ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```1 方法执行以下步骤：
   a. 调用 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```2 将 Essay 分割成句子  
   b. 对每个句子调用 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```3 进行分词

6. 处理结果通过各层逐级返回，最终由 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```4 返回 HTTP 响应。

这个流程展示了如何在 DDD 架构中处理一个请求，从接口层到应用层，再到领域层和基础设施层，每一层都有其特定的职责，共同完成了保存和处理 essay 的任务。

### 启动类

您的理解是正确的。这段代码在 FastAPI 应用中的作用确实类似于 Spring Boot 中的启动类。它主要负责应用的配置和依赖注入。让我详细解释一下这段代码的作用：

1. 依赖注入设置：

   ```python
   segmentation_service = SegmentationService()
   essay_processing_service = EssayProcessingService(segmentation_service)
   essay_repository = EssayRepository()
   mapping_card_repository = MappingCardRepository()
   ```

   这部分代码创建了应用所需的各种服务和仓储的实例。这相当于在 Spring Boot 中使用 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```5 注解定义 beans。

2. 依赖注入函数：

   ```python
   def get_process_essay_use_case():
       return ProcessEssayUseCase(
           essay_processing_service,
           essay_repository,
           mapping_card_repository
       )
   ```

   这个函数定义了如何创建 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```6 实例。它类似于 Spring Boot 中的一个工厂方法。

3. 路由包含：

   ```python
   app.include_router(essay_router)
   ```

   这行代码将 essay 相关的路由包含到主应用中，类似于 Spring Boot 中的 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```7 或明确导入某个控制器。

4. 依赖覆盖：

   ```python
   app.dependency_overrides[ProcessEssayUseCase] = get_process_essay_use_case
   ```

   这行代码告诉 FastAPI 如何解析 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```8 的依赖。当某个路由需要 ```python
# application/use_cases/process_essay_use_case.py

class ProcessEssayUseCase:
    def execute(self, essay_content: str):
        essay = Essay(content=essay_content)
        saved_essay = self.essay_repository.save(essay)
        mapping_cards = self.essay_processing_service.process_essay(saved_essay)
        self.mapping_card_repository.save_all(mapping_cards)
        return {
            "essay_id": saved_essay.id,
            "mapping_cards": [self._mapping_card_to_dict(card) for card in mapping_cards]
        }
```9 时，FastAPI 会调用 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```0 函数来获取实例。这在 Spring Boot 中类似于使用 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```1 注解。

总的来说，这段代码的作用是：

1. 初始化应用所需的所有服务和仓储。
2. 定义如何创建和注入这些依赖。
3. 设置路由。
4. 配置依赖注入系统。

这确实与 Spring Boot 的启动类有很多相似之处，都是负责应用的初始化、配置和依赖管理。主要的区别在于：

- FastAPI 使用的是显式的依赖注入方式，而 Spring Boot 更多地依赖于注解和自动配置。
- FastAPI 的这种方式给了开发者更多的控制权，可以精确地定义依赖如何被创建和注入。
- Spring Boot 的依赖注入更加自动化，通常需要更少的显式配置。

这两种方法各有优势，FastAPI 的方式在某些情况下可能更加灵活和透明，而 Spring Boot 的方式则可能更加简洁和约定优于配置。

## 心法

周期上也是一个月，时间上保证到 11 点，过程不用太纠结，主要是挖掘一些自己的疑惑，最好是能复制一个项目的本质出来，所有的组件部分都用到公司对应的开源组件，多和林杨交流一些基础组件的知识

追求完整，似乎是 self-teaching 上的一个新颖概念

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/20240120153423.png)

### DDD 的包结构

- controller 在
	- polaris.interfaces.web
- service 在
	- polaris.domain.PromotionBlackListStrategyPriorityService
	- polaris.domain.impl.PromotionBlackListStrategyPriorityServiceImpl
- mapper 在
	- polaris.infrastructure.db.mapper.OperationLogMapper  
domain entity

interfaces - 对外的接口，可以是 http 的也可以是 dubbo 的

### DevOps for CICD

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/20240119234824.png)

- CI
	- SCP 协议传文件到服务器
	- ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```2
	- 最简单的：写个脚本  
		次之：gitlab cicd 集成  
		再次：Jenkins
	- 可以试试给云服务器安装 GitHub Actions Runner 并添加到 GitHub 去，它们会变成 Self-hosted Runner，不计入账号的使用时长也不会有任何滥用限制。
	- jenkins
	- 感觉你们这需求 用 git hook 触发 git pull 就足够了
	- aws 的解决方案 [How to set up a continuous deployment pipeline - Amazon Web Services](https://aws.amazon.com/getting-started/hands-on/continuous-deployment-pipeline/)
- docker
- k8s
- kubesphere

### Visualbility of API

monitoring

### Jackson - @JsonFormat

### 单点登录

#### 1. 了解 OAuth 2.0 协议

- **OAuth 2.0** 是实现第三方登录的标准协议。
- 微信和谷歌登录都是基于 OAuth 2.0。

#### 2. 微信登录集成

- 注册成为微信开发者，获取 **AppID** 和 **AppSecret**。
- 使用微信提供的 API，例如**微信网页授权**，来获取用户信息。
- 用户扫码登录时，后台需要重定向到微信授权页面，用户授权后微信会回调您的服务器，并带上用户信息。

#### 3. 谷歌登录集成

- 在 Google Cloud Platform 上创建您的项目，获取 **Client ID** 和 **Client Secret**。
- 使用 Google 的 **OAuth 2.0 API** 来请求用户的 Google 账户信息。
- 类似地，用户选择谷歌登录时，后台需要重定向到谷歌的授权页面，用户授权后谷歌会回调您的服务器，并带上用户信息。

#### 4. 实现单点登录（SSO）逻辑

- 使用**会话（Session）**或**令牌（Token）**来管理用户状态。
- 在用户第一次通过微信或谷歌登录后，创建一个唯一的身份认证，并在后续的访问中检查这个认证。
- 可以使用如 JWT（JSON Web Tokens）等技术来实现无状态的认证机制。

#### 5. 安全性考虑

- 验证重定向的 URL，确保它是您的网站或应用。
- 储存和管理用户数据时要遵守相关的隐私法规，如 GDPR 或中国的网络安全法。
- 对于敏感信息，应使用 HTTPS 等加密技术。

#### 6. 测试和调试

- 在开发过程中进行彻底的测试，确保授权流程顺畅。
- 处理好各种异常情况，如用户拒绝授权或授权过期。

#### 7. 文档和资源

- 微信和谷歌都提供了详细的开发者文档，您应该参考这些文档进行开发。
- 考虑使用现有的库和框架来简化开发过程，例如使用 OAuth 2.0 客户端库。

实现 SSO 系统是一个复杂的任务，需要考虑到用户体验、安全性和法规遵从。建议在开发过程中不断测试和优化，以确保系统的稳定和安全。

### EasyExcel 的 模型为什么要用 @lombok.EqualsAndHashCode

## Servlet 规范

鉴权、验证参数、记录日志  
![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/20240119202936.png)

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/20240118192122.png)

### 有趣的事

- [ ] 用编程式而非声明式的方式把事务写一下
- [ ] LoginInterceptor



10.88.79.133 - -[18/Jan/2024:22:01:03 +0800]"POST /galaxy/nprice/listPriceAPI.jsp?cityurl=beijing_city&fro

### CICD

  

要使用 Git 钩子（hook）触发 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```3 操作，您通常需要在服务器端设置一个 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```4 钩子。这个钩子在服务器上的 Git 仓库接收到新的提交后触发。下面是设置过程的简要说明：

#### 在服务器端仓库设置钩子

1. **定位 Git 仓库**：导航到您的 Git 仓库的 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```5 目录。这通常在仓库的 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```6 目录下。
    

    bashCopy code

    

    ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```7

    
2. **创建或编辑钩子**：在 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```8 目录中创建一个名为 ```python
# domain/services/essay_processing_service.py

class EssayProcessingService:
    def process_essay(self, essay: Essay) -> List[MappingCard]:
        self.segmentation_service.validate_essay(essay.content)
        words_info = self.segmentation_service.process_essay(essay.content)
        
        mapping_cards = []
        for word_info in words_info:
            thought = Thought(sentence=word_info['sentence'], focus_word=word_info['chinese_word'])
            mapping_card = MappingCard(thought=thought)
            mapping_cards.append(mapping_card)
        
        return mapping_cards
```9 的文件（如果不存在的话）。
    

    bashCopy code

    

    ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```0

    
3. **编写钩子脚本**：使用您喜欢的文本编辑器编辑 ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```1 文件，添加必要的脚本来执行 ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```2 操作。示例如下：
    

    bashCopy code

    

    ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```3

    

    确保将 ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```4 替换为您希望执行 ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```5 的目录的路径，并将 ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```6 替换为相应的远程名称和分支（如果有必要）。

    
4. **使钩子可执行**：更改 ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```7 文件的权限，使其成为可执行文件。
    

    bashCopy code

    

    ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```8

    

#### 注意事项

- **安全和权限**：确保在服务器上运行的脚本是安全的，且仅由授权用户访问。错误的脚本可能会导致安全风险或数据丢失。
- **环境和路径**：Git 钩子可能不会加载常规用户的 shell 环境和路径设置。确保在脚本中直接指定必要的路径和环境变量。
- **测试钩子**：在生产环境中使用之前，应该在一个安全的环境中测试钩子以确保其按预期工作。
- **日志记录**：为了便于调试，可以在钩子脚本中添加日志记录语句。

使用 Git 钩子自动化 ```python
# infrastructure/text_processing/segmentation_service.py

class SegmentationService:
    def validate_essay(self, essay: str) -> None:
        if not essay.strip():
            raise ValueError("作文内容不能为空。")
        if len(essay) > 1500:
            raise ValueError("作文内容不能超过1500个字。")

    def process_essay(self, essay: str) -> List[Dict[str, str]]:
        sentences = self.split_into_sentences(essay)
        words = []
        for sentence in sentences:
            words.extend(self.segment_sentence(sentence))
        return words

# infrastructure/repositories/essay_repository.py

class EssayRepository:
    def save(self, essay: Essay) -> Essay:
        # 实现保存 Essay 到数据库的逻辑
        pass

# infrastructure/repositories/mapping_card_repository.py

class MappingCardRepository:
    def save_all(self, mapping_cards: List[MappingCard]):
        # 实现批量保存 MappingCard 到数据库的逻辑
        pass
```9 操作可以是一个强大的工具，但请谨慎使用，并确保您完全理解其工作原理和潜在的影响。
