---
aliases: [covariant]
draw: 
tags: []
title: 协变
date created: 2024-09-18
date modified: 2024-11-12
---

## 定义

定义：covariant，类型 Son 是类型 Father 的子类型，那么数组类型 `Son[]` 就是 `Father[]` 的子类型。

数组是协变的：Array[父，父，父]是 Array[子，子，子]的父类型  
List 不是协变的：List[父，父，父]不是 List[子，子，子]的父类型

## 为什么会这样设计？

是 Java 的历史原因导致的：

- **早期设计决策**：在 Java 的早期版本中（Java 1.0 和 1.1），泛型还不存在。数组是主要的集合类型，设计成协变可以提供更大的灵活性。
- **向后兼容**：2004 年，Java5 引入了泛型，一旦数组被改成非协变的，改变这种行为会破坏大量现有代码。因此，出于兼容性的考虑，数组的协变性被保留下来。

### 早期把数组设计成协变的好处是啥？

说白了就是和多态一样，为了灵活

用可以协变的数组时，下面这样就是 OK 的

```java
class Animal {}
class Dog extends Animal {}

class AnimalShelter {
    public Animal[] getAnimals() {
        return new Animal[10];
    }
}

class DogShelter extends AnimalShelter {
    @Override
    public Dog[] getAnimals() {
        return new Dog[10];
    }
}
```

因为 List 泛型不能协变，所以下面就是不 OK 的，会报编译错误 `attempting to use incompatible return type`

```java
class AnimalShelter {  
    public List<Animal> getAnimals() {  
        return null;  
    }  
}  
  
class DogShelter extends AnimalShelter {  
    @Override  
    public List<Dog> getAnimals() {  
        return null;  
    }  
}
```

### 但是这样并不安全

```Java
数组是协变的，编译时检查不出来，运行时会报错
编译时：Number[] numbers = new Integer[10]; // 合法
运行时：numbers[0] = 3.14; // 运行时抛出 ArrayStoreException

List不是协变的，编译时就会报错，不会等到运行时才暴露
编译时：List<Number> numberList = new ArrayList<Integer>(); // 编译错误
```

## 总结

`数组T[]`   `List<T>`，从外表上给我们一种 两个 `T` 是一个意思的感觉，其实是完全不同的两种东西。
`String[]` 在运行时知道自己是包含 String 类型元素的数组，而 ```java
class AnimalShelter {  
    public List<Animal> getAnimals() {  
        return null;  
    }  
}  
  
class DogShelter extends AnimalShelter {  
    @Override  
    public List<Dog> getAnimals() {  
        return null;  
    }  
}
```0 根本不知道自己里面装着啥

> [!最佳实践]
> 所以只有 ```java
class AnimalShelter {  
    public List<Animal> getAnimals() {  
        return null;  
    }  
}  
  
class DogShelter extends AnimalShelter {  
    @Override  
    public List<Dog> getAnimals() {  
        return null;  
    }  
}
```1 的 ```java
class AnimalShelter {  
    public List<Animal> getAnimals() {  
        return null;  
    }  
}  
  
class DogShelter extends AnimalShelter {  
    @Override  
    public List<Dog> getAnimals() {  
        return null;  
    }  
}
```2 才是泛型，而 ```java
class AnimalShelter {  
    public List<Animal> getAnimals() {  
        return null;  
    }  
}  
  
class DogShelter extends AnimalShelter {  
    @Override  
    public List<Dog> getAnimals() {  
        return null;  
    }  
}
```3 的 ```java
class AnimalShelter {  
    public List<Animal> getAnimals() {  
        return null;  
    }  
}  
  
class DogShelter extends AnimalShelter {  
    @Override  
    public List<Dog> getAnimals() {  
        return null;  
    }  
}
```4 并不是
